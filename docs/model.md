# 模型与参数

装箱问题在实际工程中的应用有多种不同的约束条件变化，这里根据典型的场景总结部分约束和特性，可以参考[下料问题](/examples/material_cutting/README.md)、[生产排程](/examples/production_schedule/README.md)、[云服务器资源调度](/examples/vm_scheduling/README.md)场景理解各个约束条件的意义和用法。

## 输入常量

#### $A$ 种容器，第 $a$ 种容器的总量有 $X_a$ 个，成本权重为 $r_a$ ， 每个容器有 $n$ 个容量维度，各个维度的容量： $x_{a1}$, $x_{a2}$, $x_{a3}$, ..., $x_{an}$
装箱问题通常来说是不设置容器上限的，但由于元启发式算法在清空一个容器时的搜索的解空间极度不平滑，所以在优化时需要指定固定的容器个数。这通常意味着需要对容器数量进行二分，并多次运行算法，过程可参考()。

对容器数量进行二分的的工作未来会被自动化脚本替代，但即使自动化存在问题，即有多种类容器时，只有最后一种的数量是可以二分的，所以需要对前若干种容器给出精确的数量评估。也许类似于网格搜索的方法有效，但并不代表可以任意多种容器的数量。这意味着对于不同种类的容器，我们仍希望是按照优先级编排好的（前面的容器一定会被使用），否则将对计算产生影响，可参考()。

此外，为了考虑一些复杂的约束，通常需要对一些容器标记标签，这在实现上可以直接对所有容器进行区分，均认为是不同的容器种类。

#### $B$ 种物品，第 $b$ 种物品的总量有 $Y_b$ 个，成本权重为 $r_a$ ，每个物品有 $m$ 个容量维度，各个维度的占用： $y_{b1}$, $y_{b2}$, $y_{b3}$, ..., $y_{bm}$
物品的总数量上限为 $1e7$，即 $B*max_b(Y_b)<1e7$。实际上总数可以达到单机可使用的内存上限，但计算效率是未经测试的，欢迎尝试。

## 变量
#### $c_{ai,bj}$ 表示第 $a$ 类的第 $i$ 个物品放在第 $b$ 类的第 $j$ 个容器中，bool
变量是默认的，不需输入。

## 约束条件
#### 对任意 $a$ 和 $i$，满足:

$$ \sum_{bj}{\sum_{ai}{c_{ai,bj}*y_{bk}}} \leq x_{ak} $$

$$ k=1, ..., n $$

这是装箱问题的默认条件，不需要输入。

#### $a$ - $b$ 约束。一个 $a$ 类容器中最多有 $k$ 个 $b$ 类物品（可选）
这个约束实际上可以直接增加一个容量特征来实现，但为了理解的便利性以及维度过多带来的计算负担，额外实现了一个约束。实际上每个特征对于所有容器和物品来说应当是普遍的，且其数量应当尽量少。

#### $b$ - $b$ 约束 一个 $b_1$ 物品最多和 $k$ 个 $b_2$ 物品在同一个容器中（可选）
这个约束用于打散一些不能相互兼容的物品。当然，如果某个约束是普遍的，那它也可以额外定义一个容量特征来进行约束。

## 最优化函数

$$Minimize(\sum_{ai}{(signal(\sum_{bj}{c_{ai,bj}})}{rx}))$$

这里使用每个容器定义的权重作为成本。实际上是可以实现任意定义的最优化函数的，但这里我还没有选型好实现自定义功能的方案，例如用户提供的动态链接库或使用parser解析用户提供的计算公式。

## 其他算法参数
#### 线程数 thread_num
整数，目前计算框架是单机多核心的，线程数需要小于等于可使用的核心数，超过则会降低效率。目前测试过的最多12核心，如果你有更多核心，那么线程数更多会更好。理论上建议不超过最优解的容器总数1/2（1000个容器则最多使用500线程），但一些线程同步问题可能会降低这个值（未经测试)。

#### 随机剪枝阈值 pruning_rate
0-1的实数，默认为0.5，表示随机剪枝时的概率大小。按照问题的规模不同而不同，越大剪掉的越多，迭代速度会越快，但迭代一次找到更优解的可能会更低。

#### 退火的升温参数 temperature_increasing_rate
实数，默认为0，升温参数越大，跳出局部最优的可能性越大。